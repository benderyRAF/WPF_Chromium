<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="utf-8">
  <script src="./libs/v6.5.0-dist/ol.js"></script>
  <script src="./libs/olcesium.js"></script>
  <script src="./libs/Build/CesiumUnminified/Cesium.js"></script>
  <link rel="stylesheet" href="./libs/v6.5.0-dist/ol.css">
</head>
<style>
  .map {
    height: 95vh;
    width: 100%;
  }
</style>
<body>
  <div id="map" class="map"></div>
  <input id="enable" type="button" value="Enable/disable" />
  <input id="a" type="number" value="35.269343"/>
  <input id="b" type="number" value="32.856909"/>
  <input id="c" type="number" value="100"/>
  <input id="addpoints" type="button" value="ADD POINT" onclick="addPoint('defult',document.getElementById('a').value,document.getElementById('b').value,document.getElementById('c').value)"/>
  <input id="altData" hidden>;
  <script>

  const handler = new Cesium.ScreenSpaceEventHandler();

  var mousePosition;
  var pointDictionary = {}

  var holderPolygon = null;
  var holderPoints = [];
  var holderPoint = -2;


  var ol2d = new ol.Map({
    target: 'map',
    view: new ol.View({
      zoom: 5,
      center: ol.proj.transform([35.0818, 31.4117], 'EPSG:4326', 'EPSG:3857'),
    }),
    layers: [
      // add local tiles
      new ol.layer.Tile({
          source: new ol.source.XYZ({
              url: 'tiles/{z}/{x}/{y}.png',
              maxZoom: 17
          })
      }),
    ]
  });

  var ol3d = new olcs.OLCesium({
    map: ol2d,
  });

  var scene = ol3d.getCesiumScene();
  // add local terrain tiles, need to be on local web server
  var terrainProvider = new Cesium.CesiumTerrainProvider({
    url : 'http://localhost:9002/tilesets/tiles'
  });
  scene.terrainProvider = terrainProvider;

  //enable 3d by default
  ol3d.setEnabled(true);

  // change between 2d to 3d
  var setEnabled = function () {
    modeSwitch()
  };
  document.getElementById('enable').addEventListener('click', setEnabled);

  // Get a reference to the ellipsoid.
  var ellipsoid = scene.globe.ellipsoid;

  // add random point for example
  var pointOfInterest = Cesium.Cartographic.fromDegrees(
    35.04592791446208, 31.48658108795938, 5000, new Cesium.Cartographic());

  // Sample terrain is asynchronous function, so wait until the map loaded
  document.addEventListener('DOMContentLoaded', async function() {

    // get the height og the point
    await Cesium.sampleTerrain(scene.terrainProvider, 11, [pointOfInterest]);
    var points = scene.primitives.add(new Cesium.PointPrimitiveCollection());

  }, false);

  
  //Cesium.sampleTerrain(scene.terrainProvider, 11, [pointOfInterest]);
  var points = scene.primitives.add(new Cesium.PointPrimitiveCollection());
  


  //function will remove all the points
  function clearPoints() {
    points.removeAll(); 
  }

  //function gets id,x,y,z and places a point there
  function addPoint(id, x, y, z) {

    // Creates and adds point to scene
    var point = points.add({
      position : Cesium.Cartographic.toCartesian( Cesium.Cartographic.fromDegrees(
      parseFloat(x), parseFloat(y), parseFloat(z), new Cesium.Cartographic()), ellipsoid),
      color : Cesium.Color.RED,
      pixelSize : 10,
    });

    // Adds point to points collection
    pointDictionary[id] = point

  }

  //function creates polyline using given positions array
  function addPolyline(points, width = 10) {
    //creates line variable
    var line = new Cesium.GeometryInstance({
    geometry : new Cesium.GroundPolylineGeometry({
      positions : Cesium.Cartesian3.fromDegreesArray(points),
      width : width
    })});
    // adds line to scene
    scene.groundPrimitives.add(new Cesium.GroundPolylinePrimitive({
    geometryInstances : line,
    allowPicking : true,
    appearance : new Cesium.PolylineMaterialAppearance()
    }));
  }

  //move camera to position given
  function moveTo(x,y,z) {
    scene.camera.flyTo({
      destination : Cesium.Cartesian3.fromDegrees(x, y, z)
    });
  }
  
  //gets cesium entities variable
  const viewer = ol3d.getDataSourceDisplay().defaultDataSource;
  const entities = viewer.entities;
  //function creates polygon using given positions array and height
  function addPolygon(points, height = 100, opacity = 1) {
    //adds polygon
    entities.add({
      polygon: {
        hierarchy: new Cesium.CallbackProperty(() => {
          return new Cesium.PolygonHierarchy(
            Cesium.Cartesian3.fromDegreesArray(points)
          )
        }, false),
        height: 2000.0,
        extrudedHeight: height,
        outline: true,
        outlineColor: Cesium.Color.WHITE,
        outlineWidth: 4,
        material: Cesium.Color.fromRandom({ alpha: opacity }),
      },
    });
  }

  //adds an image waypoint using given image url and given location
  function addImage(x,y,z,url) {
    entities.add({
      position: Cesium.Cartesian3.fromDegrees(x, y, z),
      billboard: {
        image: url,
        height: 30,
        width: 30
      },
    });
  }

  //function switches between 2d and 3d
  function modeSwitch() {
    //if its in 2d mode change to 3d
    if(scene._mode == 1)
    {
      scene._mode = 3;
      //fix camera location bug
      scene.camera.flyTo({
      destination : scene.camera.position,
      orientation : {
          heading : Cesium.Math.toRadians(0),
          pitch : Cesium.Math.toRadians(-90),
          roll : 0.0
      }});
      scene.camera.zoomOut(100000000);
    } 
    else //if its in 3d changes to 2d
    {
      scene._mode = 1;
      //fix camera location bug
        scene.camera.flyTo({
        destination : scene.camera.position,
        orientation : {
            heading : Cesium.Math.toRadians(0),
            pitch : Cesium.Math.toRadians(-90),
            roll : 0.0
        }});
      scene.camera.zoomOut(10000);
    }
  }

  // adds a 3d model to the map
  // takes url to the 3d model, x and y position amd height to put the 3d model at
  function createModel(url, x, y, height) {

    //sets the variables needed to crete the 3d model on the map
    const position = Cesium.Cartesian3.fromDegrees(
      x, y, height
    );
    const heading = Cesium.Math.toRadians(135);
    const pitch = 0;
    const roll = 0;
    const hpr = new Cesium.HeadingPitchRoll(heading, pitch, roll);
    const orientation = Cesium.Transforms.headingPitchRollQuaternion(
      position,
      hpr
    );

    // adds 3d model entity to the map 
    const entity = viewer.entities.add({
      name: url,
      position: position,
      orientation: orientation,
      model: {
        uri: url,
        minimumPixelSize: 128,
        maximumScale: 2000000,
      },
    });
    viewer.trackedEntity = entity;
  }

  // Loads structure model to map. 3d tiles (json format)
  function loadStructureModel(url) {

    const tileset = scene.primitives.add(new Cesium.Cesium3DTileset({
      url : url
    }));

    tileset.allTilesLoaded.addEventListener(function() {
      console.log('All tiles are loaded');
    });

    // tileset.readyPromise.then(function(tileset) {
    //     // Set the camera to view the newly added tileset
    //     console.log('Moving camera');
    //     scene.camera.viewBoundingSphere(tileset.boundingSphere, new Cesium.HeadingPitchRange(0, 100, 0));
    // });

  }

  // Set new position to point by id.
  function movePoint(id, x, y, z) {

    if (!(id in pointDictionary)) { return } // Does point exist.

    pointDictionary[id].position = Cesium.Cartographic.toCartesian( Cesium.Cartographic.fromDegrees(
      parseFloat(x), parseFloat(y), parseFloat(z), new Cesium.Cartographic()), ellipsoid)
    
  }

  // Convert mouse position on screen to (longitude,latitude) position.
  function convertScreenPixelToLocation(mousePosition) {

    const ellipsoid = scene.globe.ellipsoid;
    const cartesian = scene.camera.pickEllipsoid(mousePosition, ellipsoid)
    const cartographic = ellipsoid.cartesianToCartographic(cartesian)
    const longitudeString = Cesium.Math.toDegrees(cartographic.longitude)
    const latitudeString = Cesium.Math.toDegrees(cartographic.latitude)
    return {latitude: Number(latitudeString), longitude: Number(longitudeString)}

  }

  var clickId = 0;
  function addPointByClick() {
    
    // Gets point position from mouse position.
    const selectedLocation = convertScreenPixelToLocation(mousePosition)
    id = `point_${clickId}`
    clickId++;

    addPoint(id, selectedLocation.longitude, selectedLocation.latitude, 0)

    // Returns point's info to wpf.
    return JSON.stringify({
      id: id,
      position: {
        longitude: selectedLocation.longitude,
        latitude: selectedLocation.latitude
      }
    })

  }

  function clearPoints(pointIds) {

    console.log(pointIds)
    clickId = 0;
    pointIds.forEach(id => {
      points.remove(pointDictionary[id]); 
      delete pointDictionary[id];
    });

  }

  function addCircle(x, y, z = 100, semiMinorAxis = 1000000, semiMajorAxis = 1000000) {
    const greenCircle = viewer.entities.add({
      position: Cesium.Cartesian3.fromDegrees(x, y, z),
      ellipse: {
        semiMinorAxis: semiMinorAxis,
        semiMajorAxis: semiMajorAxis,
        height: 200000.0,
        material: Cesium.Color.GREEN,
        outline: true, // height must be set for outline to display
      },
    });
  }

  // Pick polygon.
  handler.setInputAction(function(click) {

    event.preventDefault(); // disable mouse action to not move screen
    var pickedObject = scene.pick(click.position); // pick the object the mouse clicked on 
    if (Cesium.defined(pickedObject)) {

      holderPolygon = pickedObject;
      var points = Cesium.Ellipsoid.WGS84.cartesianArrayToCartographicArray(holderPolygon.id.polygon.hierarchy.getValue().positions);
      
      var cameraPosition = scene.camera.positionWC;
      var ellipsoidPosition = scene.globe.ellipsoid.scaleToGeodeticSurface(cameraPosition);
      var cameraHeight = Cesium.Cartesian3.magnitude(Cesium.Cartesian3.subtract(cameraPosition, ellipsoidPosition, new Cesium.Cartesian3()));

      position = convertScreenPixelToLocation(mousePosition);
      pointCount = -2;
      points.forEach(point => {

        pointCount += 2;
        if (Math.sqrt(Math.pow(position.longitude - point.longitude * 180 / Math.PI, 2) + Math.pow(position.latitude - point.latitude * 180 / Math.PI, 2)) < cameraHeight / 5000000) {
          holderPoint = pointCount;
        }

        holderPoints.push(point.longitude * 180 / Math.PI)
        holderPoints.push(point.latitude * 180 / Math.PI)

      });

      holderPolygon.id.polygon.hierarchy = new Cesium.CallbackProperty(() => {
        return new Cesium.PolygonHierarchy(
          Cesium.Cartesian3.fromDegreesArray(holderPoints)
        )
      }, false)

      scene.screenSpaceCameraController.enableRotate = false

    }

  }, Cesium.ScreenSpaceEventType.LEFT_DOWN);

  // Updates mouse position.
  // Drags polygon if hold one.
  handler.setInputAction(function(movement) {
    
    // event.preventDefault(); // disable mouse action to not move screen
    mousePosition = movement.endPosition

    if (Cesium.defined(holderPolygon)) {

      startPosition = convertScreenPixelToLocation(movement.startPosition)
      endPosition = convertScreenPixelToLocation(movement.endPosition)
      var deltaX = endPosition.longitude - startPosition.longitude
      var deltaY = endPosition.latitude - startPosition.latitude

      if (holderPoint == -2) {
        for (let i = 0; i < holderPoints.length; i += 2) {
          holderPoints[i] = holderPoints[i]  + deltaX
          holderPoints[i + 1] = holderPoints[i + 1]  + deltaY
        }
      }
      else {
        holderPoints[holderPoint] = holderPoints[holderPoint]  + deltaX
        holderPoints[holderPoint + 1] = holderPoints[holderPoint + 1]  + deltaY
      }

    }
    
  }, Cesium.ScreenSpaceEventType.MOUSE_MOVE);
  
  // Leaves polygon.
  handler.setInputAction(function(click) {

    event.preventDefault(); // disable mouse action to not move screen

    if (Cesium.defined(holderPolygon)) {

      var points = Cesium.Ellipsoid.WGS84.cartesianArrayToCartographicArray(holderPolygon.id.polygon.hierarchy.getValue().positions);
      var newPoints = [];

      points.forEach(point => {
        newPoints.push(point.longitude * 180 / Math.PI)
        newPoints.push(point.latitude * 180 / Math.PI)
      });

      holderPolygon.id.polygon.hierarchy = new Cesium.CallbackProperty(() => {
        return new Cesium.PolygonHierarchy(
          Cesium.Cartesian3.fromDegreesArray(newPoints)
        )
      }, false)

      holderPolygon = null;
      holderPoints = [];
      holderPoint = -2;
      scene.screenSpaceCameraController.enableRotate = true;

    }

  }, Cesium.ScreenSpaceEventType.LEFT_UP);

  // double click on entitiy object deletes the object
  handler.setInputAction(function(click) {

    event.preventDefault(); // disable mouse action to not move screen
    var pickedObject = scene.pick(click.position); // pick the object the mouse clicked on 
    if (Cesium.defined(pickedObject))
    {
      // var selectedpolypoints = Cesium.Ellipsoid.WGS84.cartesianArrayToCartographicArray(pickedObject.id.polygon.hierarchy._value.positions);
      // selectedpolypoints.forEach(point => {
      //   point.longitude = point.longitude * 180 / Math.PI;
      //   point.latitude = point.latitude * 180 / Math.PI;
      // });
      entities.removeById(pickedObject.id._id); // delete the object set to be deleted (been makred as noted to test finding selected polygon points)
    }

  }, Cesium.ScreenSpaceEventType.LEFT_DOUBLE_CLICK);
function printToExport()
{
  var saving_string = "";
  for (let i = 0; i < entities.values.length; i++) {
    const element = entities.values[i];
    polypoints = Cesium.Ellipsoid.WGS84.cartesianArrayToCartographicArray(element._polygon._hierarchy.getValue().positions);
    var creation_string = "addPolygon(["; 
    polypoints.forEach(point => {
      creation_string += (point.longitude * 180 / Math.PI).toString();
      creation_string += ", ";
      creation_string += (point.latitude * 180 / Math.PI).toString();
      creation_string += ", ";
      });
      creation_string += "]);"
      console.log(creation_string);
      saving_string += creation_string; 
      saving_string += " ";  
  }
  return saving_string;
}

function getAltitOfPointById(pointID) { // will only work with points in terrain data provided
  if (!(pointID in pointDictionary))
  { return "this point id doesnt exist" } // Does point exist.
  //gets altitute of the point (async)
  Cesium.sampleTerrain(scene.terrainProvider, 11, [Cesium.Cartographic.fromCartesian(pointDictionary[pointID].position)]).then(function(samples) {
    document.getElementById("altData").value = samples[0].height; 
  });
}

function getAltitOfPointByLocation(x,y) { // will only work with points in terrain data provided
  //gets altitute of the point (async)
  Cesium.sampleTerrain(scene.terrainProvider, 11, [Cesium.Cartographic.fromDegrees(x,y)]).then(function(samples) {
  document.getElementById("altData").value = samples[0].height; 
  });
}
function getAltData(){
  return document.getElementById("altData").value
}
</script>
</body>
</html>